type AnyArray = readonly unknown[];
type Union2Intersection<U> = (U extends unknown ? (arg: U) => void : never) extends (arg: infer I) => void ? I : never;
type Pop<T extends AnyArray> = T extends [...infer Head, unknown] ? Head : T extends readonly [...infer Head, unknown] ? readonly [...Head] : never;
type Shift<S extends AnyArray, T extends AnyArray> = T extends [...S, ...infer Rest] ? Rest : never;
type UnionFactorial<T extends AnyArray> = T extends readonly [] ? never : T | UnionFactorial<Pop<T>>;
type OverloadsByArgs<Args extends AnyArray, FullArgs extends AnyArray, ReturnValue> = Args extends unknown ? CurriedWithFixArgs<Args, Shift<Args, FullArgs>, ReturnValue> : never;
type CurriedWithFixArgs<Args extends AnyArray, RestArgs extends AnyArray, ReturnValue> = (...args: Args) => Curried<RestArgs, ReturnValue>;
type Curried<Args extends AnyArray, ReturnValue> = Args extends [] ? ReturnValue : Union2Intersection<OverloadsByArgs<UnionFactorial<Args>, Args, ReturnValue>>;
export declare const curry: <T extends unknown[], R>(fn: (...args: T) => R) => T["length"] extends 0 ? () => R : Curried<T, R>;
export {};
