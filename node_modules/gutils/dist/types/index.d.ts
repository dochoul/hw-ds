export type ValueOf<T> = T[keyof T];
export type EntryOf<T> = [keyof T, T[keyof T]];
export type RecursivePartial<T> = {
    [P in keyof T]?: T[P] extends (infer U)[] ? RecursivePartial<U>[] : T[P] extends object | undefined ? RecursivePartial<T[P]> : T[P];
};
export type SetStateAction<S> = S | ((prevState: S) => S);
export type RequiredSome<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
export type PartialSome<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export type FlattenKeys<T extends Record<string, unknown>, Key = keyof T> = Key extends string ? T[Key] extends Record<string, unknown> ? `${Key}.${FlattenKeys<T[Key]>}` : `${Key}` : never;
export type ArrayOrSingle<T> = T | T[];
export type ArrayOrSet<T> = T[] | Set<T>;
export type ExtractArrayOrSet<T> = T extends ArrayOrSet<infer U> ? U : never;
